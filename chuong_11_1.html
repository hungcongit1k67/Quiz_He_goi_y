<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>100 Câu Hỏi Trắc Nghiệm - Hệ Gợi Ý Hội Thoại</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 900px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 0 15px rgba(0,0,0,0.1); }
        header { text-align: center; border-bottom: 2px solid #d9534f; margin-bottom: 30px; padding-bottom: 20px; }
        header h1 { color: #d9534f; margin: 0; }
        header p { margin: 5px 0 0; font-style: italic; color: #555; }
        .question-block { margin-bottom: 25px; padding: 20px; border: 1px solid #ddd; border-left: 5px solid #d9534f; border-radius: 5px; background-color: #fdfdfd; }
        .question-text { font-weight: bold; font-size: 1.1em; margin-bottom: 15px; }
        .options { list-style-type: none; padding-left: 0; }
        .options li { margin-bottom: 10px; padding: 8px; border-radius: 4px; }
        .explanation { margin-top: 15px; padding: 15px; background-color: #e9f7ef; border: 1px solid #a3d9b8; border-radius: 5px; }
        .explanation b { color: #1d7b46; }
        .correct-answer { background-color: #dff0d8; border-left: 3px solid #3c763d; }
        .fill-in-answer { font-weight: bold; color: #3c763d; font-size: 1.2em; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>100 Câu Hỏi Trắc Nghiệm - Hệ Gợi Ý Hội Thoại</h1>
            <p>Dựa trên nội dung slide "Conversational Recommender Systems" - Francesco Ricci</p>
        </header>

        <!-- CATEGORY: INTRODUCTION & CONCEPTS -->
        <div class="question-block"><p class="question-text">Câu 1: Theo slide 2, lời khuyên mà một nhân viên bán hàng cung cấp cho khách hàng thường có đặc điểm gì? (Câu gốc: "Typically the advise provided by a clerk to a customer is multi-stage")</p><ul class="options"><li>A. Chỉ có một giai đoạn (single-stage).</li><li class="correct-answer">B. Có nhiều giai đoạn (multi-stage).</li><li>C. Luôn luôn đúng.</li><li>D. Dựa trên lọc cộng tác.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 2 nêu rõ: "Thông thường, lời khuyên do một nhân viên cung cấp cho khách hàng là đa giai đoạn."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 2: Cuộc hội thoại trong hệ thống gợi ý hội thoại dựa trên điều gì? (Câu gốc: "Conversations are based on user requests (queries)")</p><ul class="options"><li>A. Lịch sử mua hàng của người dùng.</li><li class="correct-answer">B. Các yêu cầu (truy vấn) của người dùng.</li><li>C. Thông tin từ mạng xã hội.</li><li>D. Sự phổ biến của sản phẩm.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 2 ghi: "Các cuộc hội thoại dựa trên các yêu cầu (truy vấn) của người dùng."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 3: Hệ thống gợi ý "một lần" (Single-shot) xử lý các truy vấn trong cùng một phiên làm việc như thế nào?</p><ul class="options"><li>A. Kết hợp chúng lại với nhau.</li><li class="correct-answer">B. Xử lý chúng một cách độc lập.</li><li>C. Chỉ xử lý truy vấn đầu tiên.</li><li>D. Yêu cầu người dùng xác nhận lại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 4 mô tả hệ thống Single-shot: "Queries within even a single session are treated independently" (Các truy vấn ngay cả trong một phiên duy nhất cũng được xử lý độc lập).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 4: Tại sao hệ thống gợi ý hội thoại (Conversational) lại cần thiết?</p><ul class="options"><li>A. Vì người dùng luôn biết rõ họ muốn gì ngay từ đầu.</li><li class="correct-answer">B. Vì khách hàng hiếm khi có thể chỉ định tất cả các yêu cầu của họ ngay từ đầu và hiếm khi hài lòng với các gợi ý ban đầu.</li><li>C. Vì hệ thống một lần chạy quá chậm.</li><li>D. Vì hệ thống hội thoại dễ xây dựng hơn.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 4 đưa ra hai lý do: "customers are rarely able to specify all their requirements up-front" (khách hàng hiếm khi có thể chỉ định tất cả các yêu cầu của họ ngay từ đầu) và "customers are rarely satisfied with the initial recommendations" (khách hàng hiếm khi hài lòng với các gợi ý ban đầu).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 5: Theo slide 5, các kỹ thuật lọc cộng tác và gợi ý dựa trên nội dung thuần túy có đặc điểm gì về ngữ cảnh phiên làm việc?</p><ul class="options"><li>A. Phụ thuộc chặt chẽ vào ngữ cảnh phiên làm việc.</li><li class="correct-answer">B. Độc lập với ngữ cảnh phiên làm việc (session context independent).</li><li>C. Chỉ sử dụng ngữ cảnh từ phiên làm việc trước.</li><li>D. Luôn yêu cầu một cuộc hội thoại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 5 nêu: "Pure content-based and collaborative filtering techniques are session context independent". Gợi ý của chúng chỉ phụ thuộc vào lịch sử mua hàng dài hạn.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 6: Một hệ thống gợi ý hội thoại phải tính đến yếu tố nào?</p><ul class="options"><li>A. Chỉ lịch sử mua hàng trong quá khứ.</li><li class="correct-answer">B. Các yêu cầu được chỉ định trong suốt cuộc hội thoại.</li><li>C. Chỉ yêu cầu đầu tiên của người dùng.</li><li>D. Chỉ các gợi ý từ bạn bè.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 5 khẳng định: "A conversational recommender system must take into account the requirements specified during the conversation".</p></div></div>
        
        <!-- CATEGORY: FAILING QUERIES & REPAIR METHODS -->
        <div class="question-block"><p class="question-text">Câu 7: Một "truy vấn thất bại" (failing query) trong hệ gợi ý là gì?</p<ul class="options"><li>A. Một truy vấn trả về quá nhiều kết quả.</li><li class="correct-answer">B. Một truy vấn không trả về kết quả nào (no result).</li><li>C. Một truy vấn có lỗi cú pháp.</li><li>D. Một truy vấn chạy quá chậm.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 6 đưa ra ví dụ về một truy vấn phức tạp và kết luận: "BUT sometime... a query may return: no result".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 8: Hệ thống gợi ý dựa trên bộ lọc (Filter-Based Recommenders) tìm kiếm kết quả như thế nào?</p><ul class="options"><li>A. Tìm kiếm các kết quả tương tự.</li><li class="correct-answer">B. Tìm kiếm sự khớp chính xác (exact matching).</li><li>C. Tìm kiếm các kết quả phổ biến.</li><li>D. Tìm kiếm dựa trên đánh giá của người dùng khác.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 7 mô tả chúng là "recommenders based on query processing that search for exact matching".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 9: Hành vi "stonewalling" (dựng tường đá) của một hệ thống gợi ý có nghĩa là gì?</p><ul class="options"><li>A. Cung cấp rất nhiều lựa chọn cho người dùng.</li><li class="correct-answer">B. Không để lại nhiều lựa chọn cho người dùng khi truy vấn của họ không tìm thấy kết quả khớp chính xác.</li><li>C. Luôn luôn tìm thấy kết quả.</li><li>D. Trả lời rất nhanh.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 7 mô tả hệ thống filter-based là "stubborn clerk" (một nhân viên cứng đầu) và "does not leave much options to the user (stonewalling)".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 10: Theo slide 9, có hai cách chính để đối phó với các truy vấn thất bại. Đó là gì?</p><ul class="options"><li>A. Bỏ qua truy vấn và yêu cầu người dùng thử lại.</li><li class="correct-answer">B. Tránh vấn đề xảy ra (ví dụ: Google) và Hỗ trợ người dùng thoát khỏi ngõ cụt.</li><li>C. Hiển thị thông báo lỗi và dừng lại.</li><li>D. Gợi ý các sản phẩm ngẫu nhiên và hỏi người dùng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 9 liệt kê hai cách: "1. to avoid the problem ... using a query model that never fails" và "2. Supporting the user to escape from this dead end".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 11: "Query relaxation" là một phương pháp tiếp cận để làm gì?</p><ul class="options"><li>A. Để thắt chặt truy vấn.</li><li class="correct-answer">B. Hợp tác với người dùng để giải thích nguyên nhân thất bại và đề xuất các hành động sửa chữa.</li><li>C. Bỏ qua truy vấn của người dùng.</li><li>D. Luôn hiển thị các lựa chọn phổ biến.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 9 định nghĩa "Query relaxation: cooperate with the user to explain the cause of failure and suggest repair actions".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 12: Hệ thống tìm kiếm của Google hiếm khi thất bại vì sao?</p><ul class="options"><li>A. Vì nó có tất cả các trang web trên thế giới.</li><li class="correct-answer">B. Vì nó sử dụng một mô hình nới lỏng ngầm (Implicit Relaxation), luôn cố gắng tìm các kết quả tương tự thay vì chỉ tìm kết quả khớp chính xác.</li><li>C. Vì nó chỉ tìm kiếm các trang phổ biến.</li><li>D. Vì nó yêu cầu người dùng nhập truy vấn chính xác.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 8 mô tả "Implicit Relaxation" là lý do "Queries almost never fail in search engines!". Google sẽ tự động tìm các trang có chứa một phần các từ khóa, các từ đồng nghĩa, hoặc các trang liên quan về mặt ngữ nghĩa.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 13: "Similarity Based retrieval" (truy xuất dựa trên độ tương đồng) coi một truy vấn là gì?</p><ul class="options"><li>A. Một tập các ràng buộc cứng.</li><li class="correct-answer">B. Một mẫu (pattern), tức là một ví dụ tốt được chỉ định một phần.</li><li>C. Một câu hỏi.</li><li>D. Một lệnh.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 11 định nghĩa: "Query is considered as a pattern, i.e., a partially specified good example".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 14: Trong truy xuất dựa trên độ tương đồng, các sản phẩm được sắp xếp theo tiêu chí nào?</p><ul class="options"><li>A. Theo giá.</li><li class="correct-answer">B. Theo độ tương đồng của chúng với mẫu truy vấn.</li><li>C. Theo sự phổ biến.</li><li>D. Theo thứ tự bảng chữ cái.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 11 nêu rõ: "Products are sorted according to their similarity with the query pattern."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 15: "Hiện tượng tập trung" (Concentration Phenomenon) trong không gian nhiều chiều nói lên điều gì?</p><ul class="options"><li>A. Các điểm dữ liệu tập trung tại một điểm duy nhất.</li><li class="correct-answer">B. Chuẩn (norm) của hai vector được chọn ngẫu nhiên sẽ rất giống nhau với xác suất cao, làm cho các độ đo khoảng cách trở nên kém ý nghĩa.</li><li>C. Các điểm dữ liệu cách xa nhau.</li><li>D. Dữ liệu luôn tuân theo phân phối chuẩn.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 14 giải thích hiện tượng này: "the respective norms of two randomly chosen vectors in a high dimensional space will be very similar".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 16: Một trong những nhược điểm của phương pháp nới lỏng dựa trên độ tương đồng là gì?</p><ul class="options"><li>A. Nó quá hợp tác với người dùng.</li><li class="correct-answer">B. Nó không cung cấp thông tin tóm tắt nào về cách "sửa" truy vấn.</li><li>C. Nó luôn tìm thấy quá nhiều kết quả.</li><li>D. Nó yêu cầu người dùng phải định nghĩa độ đo tương đồng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 16 chỉ ra nhược điểm: "Do not give any summary information about how to 'repair' the query (it is not cooperative)". Người dùng không biết tại sao hệ thống lại trả về kết quả đó.</p></div></div>
        
        <!-- CATEGORY: QUERY RELAXATION/TIGHTENING -->
        <div class="question-block"><p class="question-text">Câu 17: "Maximal succeeding subquery" `q'` (truy vấn con thành công tối đại) là gì?</p><ul class="options"><li>A. Một truy vấn con bất kỳ có kết quả.</li><li class="correct-answer">B. Một truy vấn con trả về kết quả, và không có truy vấn con thành công nào khác chứa nó.</li><li>C. Truy vấn con có nhiều kết quả nhất.</li><li>D. Truy vấn con nhỏ nhất có kết quả.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 18 định nghĩa: "`q'`: returns some results, and there is no other succeeding subquery `q''` that contains `q'`".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 18: "Minimal failing subquery" `q*` (truy vấn con thất bại tối thiểu) là gì?</p><ul class="options"><li>A. Truy vấn con nhỏ nhất.</li><li class="correct-answer">B. Một truy vấn con bị thất bại, nhưng bất kỳ truy vấn con thực sự nào của nó đều thành công.</li><li>C. Truy vấn ban đầu `q`.</li><li>D. Một truy vấn con có kết quả.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 18 định nghĩa: "`q*`: is a failing subquery of `q` but any of its subqueries are succeeding". Nó là "lý do" nhỏ gọn nhất gây ra sự thất bại.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 19: Tại sao việc hiển thị tất cả các "minimal failing subqueries" lại đòi hỏi nỗ lực lớn từ người dùng?</p><ul class="options"><li>A. Vì danh sách quá ngắn.</li><li class="correct-answer">B. Vì người dùng phải xem tất cả, tự xác định ràng buộc cần loại bỏ, và cố gắng tìm các ràng buộc chung.</li><li>C. Vì thông tin không chính xác.</li><li>D. Vì hệ thống không cho phép.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 22 mô tả nỗ lực này: "The user must look at all the minimal failing queries", "Then determine a constraint to remove...", "Try to find the constraints that occur in several...".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 20: Cách tiếp cận "ngây thơ" ("Naive" Approach) (slide 30) đề xuất các phép nới lỏng (relaxations) nào?</p><ul class="options"><li>A. Các phép nới lỏng phức tạp nhất.</li><li class="correct-answer">B. Các phép nới lỏng đơn giản nhất, bằng cách chỉ thay đổi một ràng buộc duy nhất.</li><li>C. Chỉ nới lỏng ràng buộc về giá.</li><li>D. Nới lỏng tất cả các ràng buộc cùng lúc.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 30 mô tả cách tiếp cận này: "suggests to the user what are the simplest successful relaxations" bằng cách "Look for all relaxed sub-queries that change one single constraint".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 21: FAH (Feature Abstraction Hierarchy) là gì?</p<ul class="options"><li>A. Một loại thuật toán gợi ý.</li><li class="correct-answer">B. Một mối quan hệ phân cấp giữa một tập các thuộc tính trong không gian item.</li><li>C. Một phương pháp đánh giá.</li><li>D. Một cấu trúc dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 28 định nghĩa: "Each FAH (Feature Abstraction Hierarchy) is a relationship among a set of features of an item space".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 22: FAH(country, county, city) có nghĩa là gì?</p><ul class="options"><li>A. City trừu tượng hơn country.</li><li class="correct-answer">B. Country trừu tượng hơn county, và county trừu tượng hơn city.</li><li>C. Cả ba có mức độ trừu tượng như nhau.</li><li>D. Country và city có quan hệ chức năng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 28 giải thích: "FAH(country, county, city) means that country is more abstract than county, and county is more abstract than city".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 23: Trong thuật toán Query Relaxation (slide 29), khi nới lỏng một nhóm ràng buộc, thuật toán sẽ xem xét ràng buộc nào trước?</p><ul class="options"><li>A. Ràng buộc trừu tượng nhất.</li><li class="correct-answer">B. Ràng buộc cụ thể nhất (ít trừu tượng nhất).</li><li>C. Một ràng buộc ngẫu nhiên.</li><li>D. Ràng buộc về giá.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 29, bước 2, nêu rõ: "the relaxation algorithm considers first the constraint on the more specific (less abstract) feature". Ví dụ, nới lỏng "city" trước khi nới lỏng "country".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 24: "Query Tightening" được sử dụng khi nào?</p<ul class="options"><li>A. Khi không có kết quả nào được tìm thấy.</li><li class="correct-answer">B. Khi có quá nhiều sản phẩm thỏa mãn một truy vấn.</li><li>C. Khi người dùng muốn nới lỏng truy vấn.</li><li>D. Khi hệ thống bị lỗi.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 38 nêu rõ vấn đề (Issue) là "when a large number of products satisfy a query q – the user cannot browse all of them".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 25: Giải pháp cho Query Tightening là gì?</p<ul class="options"><li>A. Hiển thị tất cả các kết quả.</li><li class="correct-answer">B. Tính điểm cho các thuộc tính chưa được ràng buộc và đề xuất các thuộc tính có điểm cao cho người dùng để họ thêm vào truy vấn.</li><li>C. Tự động thêm một ràng buộc ngẫu nhiên.</li><li>D. Yêu cầu người dùng bắt đầu lại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 38 mô tả giải pháp (Solution) là "compute a score ... and suggest to the user highly scored features".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 26: "Feature utility" trong Query Tightening được tính bằng gì?</p<ul class="options"><li>A. Chỉ bằng Entropy (H).</li><li>B. Chỉ bằng Popularity (P).</li><li class="correct-answer">C. Bằng tích của Popularity và Entropy (P*H).</li><li>D. Bằng tổng của Popularity và Entropy (P+H).</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 38 đưa ra công thức: "Feature utility = ... = P*H".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 27: Entropy của một thuộc tính (slide 39) đo lường điều gì?</p<ul class="options"><li>A. Mức độ phổ biến của thuộc tính.</li><li class="correct-answer">B. Mức độ phân tán (không chắc chắn) của các giá trị của thuộc tính đó trong tập kết quả hiện tại.</li><li>C. Tần suất sử dụng của thuộc tính.</li><li>D. Số lượng giá trị của thuộc tính.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Entropy là một độ đo từ lý thuyết thông tin. Entropy cao có nghĩa là các giá trị của thuộc tính được phân bố đều, việc thêm ràng buộc trên thuộc tính này sẽ có khả năng chia nhỏ tập kết quả một cách hiệu quả.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 28: Popularity của một thuộc tính (slide 39) đo lường điều gì?</p<ul class="options"><li>A. Mức độ phân tán của các giá trị.</li><li class="correct-answer">B. Tần suất mà thuộc tính đó được sử dụng để ràng buộc trong các truy vấn.</li><li>C. Số lượng giá trị của thuộc tính.</li><li>D. Mức độ người dùng thích thuộc tính đó.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 38 định nghĩa Popularity là "frequency of usage". Slide 39 đưa ra công thức `p^i = # of queries constraining x_i / total number of queries`.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 29: Theo ví dụ ở slide 40, thuộc tính nào có Entropy cao hơn?</p><ul class="options"><li>A. Center</li><li class="correct-answer">B. Hotel size</li><li>C. Bằng nhau</li><li>D. Không thể xác định</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 40 tính toán và cho kết quả: `H(Center) = 0.141` và `H(Hotel size) = 0.463`. Do đó, "Hotel size" có Entropy cao hơn.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 30: (Điền đáp án) Trong mô hình đánh giá Utility (slide 41), `A_i` được giả định là hành động gì của hệ thống?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Hệ thống đề xuất thuộc tính x_i để thắt chặt truy vấn (system suggests x_i for tightening).</span></p><p><b>💡 Giải thích:</b> Slide 41 ghi: "We assume that `A_i` = 'system suggests `x_i` for tightening'".</p></div></div>
        
        <!-- ... More questions from 31 to 100 ... -->
        <div class="question-block"><p class="question-text">Câu 31: (Điền đáp án) Theo slide 42, utility của trạng thái "accept" (chấp nhận) `U(S_2i-1)` là gì?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Entropy của thuộc tính trong tập kết quả (the feature entropy in the result set).</span></p><p><b>💡 Giải thích:</b> Slide 42 ghi rõ: "`U(S_2i-1) = H_R^i`: the utility of the accept tightening state is the feature entropy in the result set".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 32: (Điền đáp án) Theo slide 42, utility của trạng thái "reject" (từ chối) `U(S_2i)` là bao nhiêu và tại sao?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">0, vì hệ thống đã đưa ra một đề xuất không cần thiết.</span></p><p><b>💡 Giải thích:</b> Slide 42 ghi: "`U(S_2i) = 0`: the utility of the reject tightening state is 0 (the system made an unnecessary suggestion)".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 33: Theo slide 43, trong quá trình đánh giá Query Tightening, quyết định của người dùng mô phỏng về việc có sử dụng một đề xuất hay không được đưa ra dựa trên cái gì?</p><ul class="options"><li>A. Ngẫu nhiên hoàn toàn.</li><li class="correct-answer">B. Dựa trên một xác suất `βp^i`, với `p^i` là độ phổ biến của thuộc tính.</li><li>C. Luôn luôn chấp nhận.</li><li>D. Luôn luôn từ chối.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 43 ghi: "...the decision is taken with probability `βp^i`".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 34: Theo biểu đồ ở slide 45 (bên trái), chiến lược chọn thuộc tính nào giúp giảm kích thước tập kết quả nhanh nhất?</p><ul class="options"><li>A. Random</li><li>B. Popularity</li><li class="correct-answer">C. Utility</li><li>D. Entropy</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đường cong của Utility (đường tròn) giảm nhanh nhất và xuống mức thấp nhất, cho thấy nó giúp thu hẹp tập kết quả hiệu quả nhất sau mỗi lượt tương tác.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 35: Theo slide 48, các cách tiếp cận hội thoại có thực sự là hybrid không?</p><ul class="options"><li>A. Không, chúng là một loại riêng biệt.</li><li class="correct-answer">B. Có, và không chỉ theo nghĩa trộn lẫn ý tưởng content-based và collaborative-based.</li><li>C. Chỉ hybrid khi kết hợp với lọc cộng tác.</li><li>D. Chỉ hybrid khi kết hợp với gợi ý dựa trên nội dung.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 kết luận: "Conversational approaches are really hybrid (not only in the sense of mixing content-based and collaborative-based ideas)".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 36: Tại sao việc đánh giá hệ thống hội thoại lại tốn kém?</p><ul class="options"><li>A. Vì thuật toán quá phức tạp.</li><li class="correct-answer">B. Vì nó cần sự tương tác thực của người dùng.</li><li>C. Vì nó cần phần cứng mạnh.</li><li>D. Vì không có dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 nêu: "Evaluation of conversational system is expensive – it needs real user interaction".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 37: Trong ví dụ ở slide 12, "Probe case" là gì?</p><ul class="options"><li>A. Một case có sẵn trong Case Base.</li><li class="correct-answer">B. Truy vấn (query) của người dùng.</li><li>C. Một case được gợi ý.</li><li>D. Một case bị lỗi.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 12 có nhãn "Probe case = query", cho thấy probe case chính là truy vấn cần được so sánh với các case trong cơ sở dữ liệu.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 38: Theo slide 13, tại sao Case 4 lại là một lựa chọn tồi?</p><ul class="options"><li>A. Vì nó quá đắt.</li><li class="correct-answer">B. Vì Case 3 tương tự với truy vấn hơn.</li><li>C. Vì nó có điều kiện "poor".</li><li>D. Vì nó không có trong cơ sở dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 13 ghi: "Case 4 is surely a bad option, since case 3 is (in any case) more similar to the query".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 39: Theo định lý Beyer (slide 15), khi số chiều tăng lên, điều gì xảy ra với khoảng cách từ một điểm truy vấn đến các điểm dữ liệu xung quanh?</p><ul class="options"><li>A. Khoảng cách trở nên rất khác nhau.</li><li class="correct-answer">B. Hầu hết các điểm đều có cùng một khoảng cách đến điểm truy vấn.</li><li>C. Tất cả các điểm đều có khoảng cách bằng 0.</li><li>D. Khoảng cách tăng lên vô hạn.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 15 kết luận từ định lý Beyer: "The points are distant from the query almost all by the same distance". Điều này làm cho việc tìm "láng giềng gần nhất" trở nên vô nghĩa.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 40: (Điền đáp án) Theo slide 17, `q` là một truy vấn có kích thước kết quả là bao nhiêu?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Rỗng (empty)</span></p><p><b>💡 Giải thích:</b> Slide 18 định nghĩa: "Let `q` be a query with empty result size."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 41: Theo slide 19, một cách để tạo ra một truy vấn con thành công từ các minimal failing subqueries là gì?</p><ul class="options"><li>A. Giữ lại tất cả các ràng buộc.</li><li class="correct-answer">B. Loại bỏ một ràng buộc từ mỗi minimal failing subquery.</li><li>C. Thêm một ràng buộc mới.</li><li>D. Chỉ xem xét các truy vấn con lớn nhất.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 19 giải thích: "The user can generate one succeeding subquery removing one constraint from each minimal failing subquery".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 42: Theo slide 20, việc tìm TẤT CẢ các maximal succeeding subquery có độ phức tạp như thế nào?</p><ul class="options"><li>A. O(|q|)</li><li>B. O(|q|^2)</li><li class="correct-answer">C. Bất khả thi về mặt tính toán (intractable).</li><li>D. O(1)</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 20 ghi: "- all makes the problem intractable".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 43: Trong ví dụ ở slide 21, để giải quyết vấn đề, hệ thống đề xuất người dùng nới lỏng ràng buộc nào?</p><ul class="options"><li>A. region</li><li>B. price</li><li class="correct-answer">C. transport</li><li>D. type</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Dòng cuối cùng của slide 21 ghi: "By relaxing transport you can eliminate 6 of the unmatched combinations".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 44: Tại sao việc trình bày các maximal succeeding subqueries lại đòi hỏi ít nỗ lực hơn từ người dùng?</p><ul class="options"><li>A. Vì danh sách dài hơn.</li><li class="correct-answer">B. Vì người dùng chỉ cần chọn một trong số các lựa chọn đã được sửa sẵn.</li><li>C. Vì chúng luôn đúng.</li><li>D. Vì chúng được sắp xếp theo giá.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 22 giải thích: "Presenting to the user ... maximal succeeding subqueries requires considerably less efforts - The user must only choose one of them!".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 45: Trong giao diện NutKing+ (slide 23), khi không có kết quả, hệ thống đã đề xuất những hành động nào?</p><ul class="options"><li>A. Chỉ đề xuất "Remove" (Xóa).</li><li>B. Chỉ đề xuất "Modify" (Sửa đổi).</li><li class="correct-answer">C. Đề xuất cả "Remove" và "Modify" cho các ràng buộc khác nhau.</li><li>D. Yêu cầu người dùng tìm kiếm lại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Giao diện cho thấy các lựa chọn như "Remove 'Location'", "Modify 'Cost'", "Remove 'Outdoor swimming pool'",... Đây là các hành động sửa chữa được đề xuất.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 46: Trong kiến trúc IQM (slide 24), khối "Result Analyzer" có nhiệm vụ gì?</p><ul class="options"><li>A. Dịch truy vấn.</li><li class="correct-answer">B. Phân tích kết quả của một truy vấn để quyết định xem có cần nới lỏng (relax) hay thắt chặt (tighten) hay không.</li><li>C. Gửi sản phẩm cho Client.</li><li>D. Xử lý dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> "Result Analyzer" nằm ở vị trí trung tâm, nhận kết quả từ "Query Translation" và quyết định xem nên đi theo nhánh "Relax" hay "Tighten", cho thấy nó phân tích tình trạng của tập kết quả (ví dụ: rỗng hoặc quá lớn).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 47: Trong quy trình của Intelligent Query Manager (slide 25), nếu có quá nhiều ứng viên, hệ thống sẽ làm gì?</p><ul class="options"><li>A. Trả về tất cả.</li><li class="correct-answer">B. Tính toán và trả về các đề xuất thắt chặt truy vấn (query tightening suggestions).</li><li>C. Tính toán và trả về các đề xuất nới lỏng truy vấn.</li><li>D. Báo lỗi.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 25, bước 2, ghi: "If too many candidates, Compute & return query tightening suggestions".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 48: Trong quy trình của Intelligent Query Manager (slide 25), nếu không có ứng viên nào, hệ thống sẽ làm gì?</p><ul class="options"><li>A. Trả về một sản phẩm ngẫu nhiên.</li><li>B. Tính toán và trả về các đề xuất thắt chặt truy vấn.</li><li class="correct-answer">C. Tính toán và trả về các đề xuất nới lỏng truy vấn (query relaxation suggestions).</li><li>D. Dừng lại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 25, bước 3, ghi: "If no candidates, Compute & return query relaxation suggestions".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 49: Trong quy trình Relaxation (slide 26), bước "Feature Filtering" làm gì?</p><ul class="options"><li>A. Tìm một dạng nới lỏng cho mỗi ràng buộc.</li><li class="correct-answer">B. Xác định các ràng buộc có thể được nới lỏng.</li><li>C. Đánh giá các truy vấn đã được nới lỏng.</li><li>D. Phân tích kết quả cuối cùng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 26 định nghĩa: "Feature Filtering: identify constraints that can be relaxed". Đây là bước đầu tiên để xác định các ứng viên cho việc nới lỏng.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 50: Theo slide 27, một ràng buộc trên một thuộc tính số (numerical) có dạng như thế nào?</p><ul class="options"><li>A. `x_ik = yes`</li><li>B. `x_ik = v`</li><li class="correct-answer">C. `l ≤ x_ik ≤ u`</li><li>D. `x_ik > u`</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 27 định nghĩa ràng buộc cho thuộc tính số là `l ≤ x_ik ≤ u` (dạng khoảng).</p></div></div>

        
        <div class="question-block"><p class="question-text">Câu 51: (Điền đáp án) Theo slide 28, FAH(category, price) thể hiện điều gì?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Thuộc tính price chi tiết hơn (less abstract) so với thuộc tính category.</span></p><p><b>💡 Giải thích:</b> Slide 28 giải thích: "...the price is more fine grain (less abstract) than the category to express the cost."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 52: Trong ví dụ Query Relaxation (slide 29), các ràng buộc được nhóm thành mấy nhóm (S1, S2, S3)?</p><ul class="options"><li>A. 1</li><li>B. 2</li><li class="correct-answer">C. 3</li><li>D. 6</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Sơ đồ trên slide 29 cho thấy có 3 nhóm được tạo ra: S1 (country, area, city), S2 (category, cost), và S3 (parking).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 53: Theo slide 29, nhóm S1 được tạo ra dựa trên FAH nào?</p><ul class="options"><li class="correct-answer">A. FAH(country, area, city)</li><li>B. FAH(category, cost)</li><li>C. FAH(parking)</li><li>D. Không dựa trên FAH nào.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> S1 nhóm các ràng buộc về vị trí địa lý. Theo ví dụ ở slide 28, chúng có mối quan hệ phân cấp, với country là trừu tượng nhất và city là cụ thể nhất.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 54: Trong ví dụ ở slide 31, truy vấn `q1` được nới lỏng từ truy vấn ban đầu bằng cách nào?</p><ul class="options"><li>A. Nới lỏng ràng buộc `country`.</li><li class="correct-answer">B. Nới lỏng (loại bỏ) ràng buộc `city`.</li><li>C. Nới lỏng ràng buộc `category`.</li><li>D. Nới lỏng ràng buộc `parking`.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Truy vấn ban đầu có `city=Canazei`. Truy vấn `q1` không còn ràng buộc này. Hệ thống đề xuất "to expand the search to the whole Val di Fassa", tức là bỏ qua city và tìm trong cả vùng (region).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 55: Trong ví dụ ở slide 31, truy vấn `q2` được nới lỏng từ truy vấn ban đầu bằng cách nào?</p><ul class="options"><li>A. Nới lỏng `city`.</li><li class="correct-answer">B. Nới lỏng cả `category` và `cost`.</li><li>C. Nới lỏng `parking`.</li><li>D. Nới lỏng `region`.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Truy vấn ban đầu có `category<=2` và `cost<=40`. Truy vấn `q2` có `category<=3` và `cost<=50`. Cả hai ràng buộc này đều đã được nới lỏng.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 56: (Điền đáp án) Trong đánh giá online hệ thống NutKing (slide 32), phiên bản hỗ trợ cơ chế nới lỏng có tên là gì?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">NutKing+</span></p><p><b>💡 Giải thích:</b> Slide 32 ghi: "Half of them used a version with IQM – NutKing+".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 57: Theo kết quả ở slide 32, NutKing+ có số lượng truy vấn được gửi bởi một người dùng (Queries submitted by a user) như thế nào so với NutKing-?</p><ul class="options"><li class="correct-answer">A. Ít hơn (13.4 so với 20).</li><li>B. Nhiều hơn.</li><li>C. Tương đương.</li><li>D. Không thể so sánh.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Bảng cho thấy NutKing- có 20 ± 19.2 truy vấn, trong khi NutKing+ chỉ có 13.4 ± 9.3. Điều này có nghĩa là người dùng tìm thấy thứ họ muốn nhanh hơn với hệ thống hỗ trợ.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 58: Theo kết quả ở slide 32, NutKing+ có kích thước kết quả trung bình (Avg query result size) như thế nào so với NutKing-?</p><ul class="options"><li>A. Lớn hơn.</li><li class="correct-answer">B. Nhỏ hơn đáng kể (9.8 so với 42.0).</li><li>C. Tương đương.</li><li>D. Không thể so sánh.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Bảng cho thấy NutKing- có kích thước kết quả trung bình là 42.0, trong khi NutKing+ chỉ là 9.8. Điều này cho thấy hệ thống giúp người dùng thu hẹp phạm vi tìm kiếm hiệu quả hơn.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 59: Theo đánh giá offline ở slide 33, việc sử dụng FAH có cải thiện tỷ lệ tìm thấy truy vấn con thành công không?</p><ul class="options"><li class="correct-answer">A. Có, tỷ lệ tăng từ 62% lên 83%.</li><li>B. Không, tỷ lệ giảm.</li><li>C. Không có sự khác biệt.</li><li>D. Chỉ cải thiện cho danh mục Sport.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Nhìn vào hàng "Total", cột "subq. found without using FAH" có tỷ lệ 172/279 ≈ 62%, trong khi cột "subq. found by using FAH" có tỷ lệ 232/279 ≈ 83%.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 60: Theo biểu đồ ở slide 34, số lượng truy vấn thất bại (Failing queries) có xu hướng như thế nào khi số lượng ràng buộc tăng lên?</p><ul class="options"><li>A. Giảm đi.</li><li class="correct-answer">B. Tăng lên.</li><li>C. Không đổi.</li><li>D. Dao động ngẫu nhiên.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Nhìn vào các cột màu đen (Failing queries), chiều cao của chúng có xu hướng tăng lên khi số lượng ràng buộc (# of Constraints) tăng. Càng nhiều ràng buộc, khả năng không có kết quả nào thỏa mãn càng cao.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 61: Trong giao diện Query Tightening của NutKing (slide 37), hệ thống đề xuất người dùng làm gì khi có 24 kết quả?</p><ul class="options"><li>A. Xem tất cả 24 kết quả.</li><li class="correct-answer">B. Thêm các ràng buộc mới (ví dụ: "Cost", "Car park", "TV") để tinh chỉnh và giảm số lượng kết quả.</li><li>C. Nới lỏng các ràng buộc hiện có.</li><li>D. Bắt đầu một tìm kiếm mới.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Giao diện hiển thị: "I found 24 results... Below we suggest ways to modify your request and receive more refined results." và liệt kê các tùy chọn "Add 'Cost' to your query.",...</p></div></div>
        <div class="question-block"><p class="question-text">Câu 62: Theo slide 38, Entropy (H) được dùng để đo lường điều gì?</p><ul class="options"><li>A. Độ phổ biến của một thuộc tính.</li><li class="correct-answer">B. Entropy ước tính của các giá trị của một thuộc tính.</li><li>C. Mức độ giảm kết quả.</li><li>D. Tần suất sử dụng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 38 định nghĩa: "H: Estimated entropy of the feature values".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 63: Tại sao "Hotel size" lại là thuộc tính "tốt nhất" theo Entropy nhưng có thể không phải là thứ người dùng quan tâm nhất (slide 40)?</p><ul class="options"><li>A. Vì Entropy luôn tính sai.</li><li class="correct-answer">B. Vì Entropy chỉ đo lường khả năng phân chia dữ liệu của một thuộc tính, nó không đo lường mức độ quan tâm hay "phổ biến" của thuộc tính đó đối với người dùng.</li><li>C. Vì "Center" có Entropy cao hơn.</li><li>D. Vì người dùng không hiểu Entropy là gì.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 40 kết luận: "The 'best' feature, according to entropy is 'Hotel size' but it is probably less interesting than hotels in the 'Center'". Điều này cho thấy sự đánh đổi: một thuộc tính có thể giúp lọc kết quả rất tốt (entropy cao) nhưng lại không phải là thứ người dùng thường nghĩ đến để tìm kiếm (popularity thấp).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 64: Theo slide 45, chiến lược nào giúp giảm kích thước kết quả trung bình xuống mức thấp nhất?</p><ul class="options"><li>A. Entropy</li><li>B. Random</li><li>C. Popularity</li><li class="correct-answer">D. Utility</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Trong cả hai biểu đồ, đường cong của Utility (đường tròn) luôn nằm dưới cùng, cho thấy nó giảm kích thước tập kết quả hiệu quả nhất.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 65: Theo slide 48, có tồn tại một phương pháp tiếp cận hội thoại tốt nhất cho mọi trường hợp không?</p><ul class="options"><li>A. Có, đó là similarity-based.</li><li class="correct-answer">B. Không, nó phụ thuộc vào người dùng, sản phẩm và ngữ cảnh.</li><li>C. Có, đó là critiques.</li><li>D. Có, đó là logical query.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 kết luận: "There is no best approach: it depends on the user, product and context".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 66: (Điền đáp án) Theo slide 4, tên tác giả của slide này là gì?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Francesco Ricci</span></p><p><b>💡 Giải thích:</b> Slide 1 có tên tác giả là Francesco Ricci.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 67: Trong cuộc hội thoại ở slide 3, khi truy vấn ban đầu trả về "too many hotels", người bán hàng (Clerk) đã làm gì?</p><ul class="options"><li>A. Hiển thị tất cả các khách sạn.</li><li class="correct-answer">B. Đề xuất thêm các ràng buộc về tiện nghi (facilities) để thắt chặt truy vấn.</li><li>C. Yêu cầu khách hàng tăng giá.</li><li>D. Báo là không có khách sạn nào.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Người bán hàng đã hỏi: "Would you like to have facilities like car parking or air conditioning?". Đây là một hành động thắt chặt truy vấn (query tightening).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 68: Trong cuộc hội thoại ở slide 3, khi truy vấn sau đó trả về "no match", người bán hàng đã làm gì?</p><ul class="options"><li>A. Dừng cuộc hội thoại.</li><li class="correct-answer">B. Đề xuất các phương án nới lỏng ràng buộc (relaxing constraints).</li><li>C. Yêu cầu khách hàng giảm yêu cầu.</li><li>D. Hiển thị các khách sạn ngẫu nhiên.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Người bán hàng đã đưa ra hai lựa chọn nới lỏng: một là nới lỏng về giá ("price up to 110"), hai là nới lỏng về tiện nghi ("no parking"). Đây là ví dụ của query relaxation.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 69: (Điền đáp án) Theo slide 12, Case 1 và Case 5 trong bảng có bao nhiêu thuộc tính khớp nhau (matching attribute)?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">3</span></p><p><b>💡 Giải thích:</b> So sánh Case 1 và Probe case (Case 5), ta thấy chúng khớp nhau ở các thuộc tính: Location code (8), Bedrooms (2), và Price (20,500). Các ô này được tô màu.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 70: Theo slide 16, một nhược điểm của "Similarity-Based Relaxation" là gì?</p><ul class="options"><li>A. Nó không nới lỏng truy vấn.</li><li class="correct-answer">B. Nó nới lỏng truy vấn một cách ngầm định, khiến người dùng có thể bỏ lỡ cách nới lỏng mà họ thích nhất.</li><li>C. Nó quá phức tạp.</li><li>D. Nó đòi hỏi người dùng phải biết về lý thuyết tương đồng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 16 nêu: "It implicitly relaxes query constraints..." và "Hence the user can miss the relaxation that he would like the best."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 71: Theo slide 21, để giải quyết vấn đề, người dùng cần làm gì?</p><ul class="options"><li>A. Thêm một ràng buộc mới.</li><li class="correct-answer">B. Nới lỏng một trong các ràng buộc trong mỗi tổ hợp không khớp.</li><li>C. Tìm kiếm lại từ đầu.</li><li>D. Tăng ngân sách.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Dòng chữ cuối slide ghi: "To solve this problem, you need to relax one of the constraints in each of the unmatched combinations".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 72: Theo slide 27, ràng buộc `2<= category <=3` là loại ràng buộc trên thuộc tính gì?</p><ul class="options"><li>A. Boolean</li><li>B. Nominal</li><li class="correct-answer">C. Numerical</li><li>D. Textual</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 27 định nghĩa ràng buộc có dạng `l ≤ x_ik ≤ u` là cho thuộc tính số (numerical).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 73: Theo slide 27, ràng buộc `city=Canazei` là loại ràng buộc trên thuộc tính gì?</p><ul class="options"><li>A. Boolean</li><li class="correct-answer">B. Nominal</li><li>C. Numerical</li><li>D. Ordinal</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 27 định nghĩa ràng buộc có dạng `x_ik = v` là cho thuộc tính danh nghĩa (nominal).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 74: Theo slide 32, phiên bản nào của NutKing có số lần nới lỏng được đề xuất (times relaxation suggested) nhiều hơn?</p><ul class="options"><li>A. NutKing-</li><li class="correct-answer">B. NutKing+</li><li>C. Cả hai bằng nhau.</li><li>D. Không có dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Bảng cho thấy NutKing- không có tính năng này (n.a.), trong khi NutKing+ có 6.3 ± 3.6 lần đề xuất nới lỏng.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 75: (Điền đáp án) Theo slide 33, có bao nhiêu truy vấn thất bại (failing queries) trong danh mục "Event"?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">57</span></p><p><b>💡 Giải thích:</b> Trong bảng, hàng "Event", cột "# of failing queries", giá trị là 57.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 76: (Điền đáp án) Theo slide 33, có bao nhiêu phần trăm truy vấn thất bại trong danh mục "Sport"?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">48%</span></p><p><b>💡 Giải thích:</b> Trong bảng, hàng "Sport", cột "# of failing queries", giá trị là 49. Tổng số truy vấn là 102. Tỷ lệ là 49/102 ≈ 48%.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 77: Theo slide 39, `p^i` (Popularity) được tính như thế nào?</p><ul class="options"><li>A. Bằng tổng số truy vấn.</li><li class="correct-answer">B. Bằng số truy vấn có chứa ràng buộc `x_i` chia cho tổng số truy vấn.</li><li>C. Bằng số lượng giá trị của `x_i`.</li><li>D. Bằng Entropy của `x_i`.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 39 đưa ra công thức: `p^i = # of queries constraining x_i / total number of queries`.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 78: Theo slide 40, đặc trưng nào có giá trị entropy cao hơn nhưng lại có thể ít được người dùng quan tâm hơn?</p><ul class="options"><li>A. Center</li><li class="correct-answer">B. Hotel size</li><li>C. Price</li><li>D. Rating</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 40 kết luận: "The 'best' feature, according to entropy is 'Hotel size' but it is probably less interesting than hotels in the 'Center'".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 79: Trong mô hình Utility (slide 42), `β` là gì?</p><ul class="options"><li>A. Tốc độ học.</li><li class="correct-answer">B. Một tham số được xác định bằng thực nghiệm để điều chỉnh xác suất chấp nhận tổng thể.</li><li>C. Độ phổ biến của thuộc tính.</li><li>D. Utility của trạng thái.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 42 giải thích `β` là "a parameter determined experimentally so that the overall acceptance rate is equal to that found in real interactions."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 80: Mục tiêu của đánh giá Query Tightening (slide 43) là gì?</p><ul class="options"><li>A. Đo lường độ chính xác của gợi ý.</li><li class="correct-answer">B. Đo lường độ dài tương tác trung bình và kích thước tập kết quả trung bình ở mỗi vòng lặp.</li><li>C. Đo lường sự hài lòng của người dùng.</li><li>D. Đo lường tốc độ của hệ thống.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Dòng cuối cùng của slide 43 ghi: "We measure the (average) interaction length and the (average) size of the result set at each iteration."</p></div></div>
        <div class="question-block"><p class="question-text">Câu 81: (Điền đáp án) Theo slide 45, khi người dùng luôn chấp nhận đề xuất thắt chặt (User always accept to tighten), chiến lược nào cho kết quả tốt nhất?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Utility</span></p><p><b>💡 Giải thích:</b> Trong biểu đồ bên trái, đường của Utility (với ký hiệu hình tròn) giảm xuống mức thấp nhất, cho thấy nó là hiệu quả nhất.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 82: Theo slide 47, giả định mạnh của phong cách tương tác này là gì?</p><ul class="options"><li>A. Người dùng không biết họ muốn gì.</li><li class="correct-answer">B. Người dùng có kiến thức ("knowledgeable") về thứ họ đang tìm kiếm.</li><li>C. Người dùng luôn chấp nhận gợi ý.</li><li>D. Người dùng không muốn tương tác.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 47 nêu: "The strong assumption of this interaction style is that the user is 'knowledgeable' about what is searching...".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 83: Theo slide 48, đâu KHÔNG phải là một cách tiếp cận cho hệ thống hội thoại?</p><ul class="options"><li>A. logical query</li><li>B. similarity-based</li><li>C. critiques</li><li class="correct-answer">D. matrix factorization</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 liệt kê các cách tiếp cận là "(logical query, similarity-based, comparison, critiques)". Matrix factorization là một kỹ thuật của lọc cộng tác, không phải là một cách tiếp cận hội thoại.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 84: Theo slide 49, "What is the goal of constraint relaxation...?" có nghĩa là gì?</p><ul class="options"><li>A. Mục tiêu của việc thắt chặt ràng buộc là gì?</li><li class="correct-answer">B. Mục tiêu của việc nới lỏng ràng buộc trong mô-đun IQM của NutKing là gì?</li><li>C. Vai trò của việc nới lỏng ràng buộc là gì?</li><li>D. Làm thế nào để nới lỏng ràng buộc?</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đây là bản dịch chính xác của câu hỏi đầu tiên trong danh sách câu hỏi thảo luận ở slide 49.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 85: Theo slide 49, "How the feature (questions) are selected for tightening?" có nghĩa là gì?</p><ul class="options"><li>A. Vai trò của việc thắt chặt truy vấn là gì?</li><li class="correct-answer">B. Các thuộc tính (câu hỏi) được lựa chọn để thắt chặt như thế nào?</li><li>C. Tại sao lại cần thắt chặt truy vấn?</li><li>D. Có những hạn chế nào của việc thắt chặt?</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đây là bản dịch chính xác của một trong các câu hỏi thảo luận trên slide 49.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 86: Hệ thống gợi ý hội thoại có lợi thế gì trong việc hỗ trợ quá trình ra quyết định của người dùng?</p><ul class="options"><li>A. Chúng luôn nhanh hơn.</li><li class="correct-answer">B. Chúng xem xét bản chất động của quá trình gợi ý.</li><li>C. Chúng luôn chính xác hơn.</li><li>D. Chúng không cần dữ liệu.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 kết luận: "Conversational systems have a better chance to support the user decision process - they consider the dynamic nature of the recommendation process".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 87: (Điền đáp án) Theo slide 3, khi Clerk nói "there are 40 hotels in the desired category with parking, restaurant, but you have to consider a price up to 110", đây là một đề xuất nới lỏng ràng buộc nào?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Price (Giá)</span></p><p><b>💡 Giải thích:</b> Yêu cầu ban đầu là giá "up to 100". Đề xuất này đã nới lỏng ràng buộc về giá lên 110.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 88: (Điền đáp án) Theo slide 3, khi Clerk nói "there is one hotel with your desired category and price which has a restaurant but no parking", đây là một đề xuất nới lỏng ràng buộc nào?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Parking (Bãi đỗ xe)</span></p><p><b>💡 Giải thích:</b> Yêu cầu thứ hai của khách hàng là "car parking and restaurant". Đề xuất này đã bỏ đi ràng buộc về "parking".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 89: Theo slide 12, Case 2 và Probe case (Case 5) khác nhau ở những thuộc tính nào?</p><ul class="options"><li>A. Chỉ Price.</li><li class="correct-answer">B. Recep rooms, Type, và Price.</li><li>C. Chỉ Condition.</li><li>D. Chỉ Recep rooms và Type.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> So sánh Case 2 và Case 5, ta thấy: Recep rooms (1 vs 2), Type (terraced vs semi), Price (25,000 vs 20,500). Các thuộc tính khác đều khớp.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 90: Theo slide 13, nếu giá (price) quan trọng hơn tình trạng (condition), tại sao Case 1 lại nên được ưu tiên hơn Case 2?</p><ul class="options"><li>A. Vì Case 1 rẻ hơn.</li><li class="correct-answer">B. Vì Case 1 có giá gần với truy vấn hơn (20,500) so với Case 2 (25,000).</li><li>C. Vì Case 1 có tình trạng tốt hơn.</li><li>D. Vì Case 1 có nhiều phòng hơn.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Truy vấn (Case 5) có giá là 20,500. Case 1 cũng có giá 20,500 (độ chênh lệch là 0). Case 2 có giá 25,000 (độ chênh lệch là 4,500). Nếu giá là quan trọng, Case 1 sẽ được ưu tiên vì nó khớp chính xác về giá.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 91: Theo slide 16, tại sao người dùng lại có thể "bỏ lỡ cách nới lỏng mà anh ta muốn nhất"? (Câu gốc: "miss the relaxation that he would like the best")</p><ul class="options"><li>A. Vì hệ thống không đưa ra đề xuất nào.</li><li class="correct-answer">B. Vì hệ thống tự động nới lỏng một cách ngầm định và trả về kết quả gần đúng nhất, người dùng không biết rằng có thể có các cách nới lỏng khác (ví dụ, bỏ một ràng buộc khác) có thể dẫn đến kết quả họ thích hơn.</li><li>C. Vì có quá nhiều lựa chọn.</li><li>D. Vì người dùng không hiểu các lựa chọn.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đây là nhược điểm của "Similarity-Based Relaxation". Nó chỉ trả về một danh sách xếp hạng theo một độ đo tương đồng duy nhất, che giấu các khả năng nới lỏng khác khỏi người dùng.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 92: Theo slide 25, Intelligent Query Manager sẽ làm gì trong trường hợp "Otherwise" (tức là không quá nhiều và cũng không có ứng viên nào)?</p><ul class="options"><li>A. Đề xuất nới lỏng.</li><li>B. Đề xuất thắt chặt.</li><li class="correct-answer">C. Trả về tập ứng viên `P`.</li><li>D. Dừng lại.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Bước 4 ghi: "Otherwise, Return `P`". Điều này có nghĩa là nếu số lượng kết quả là vừa phải, hệ thống sẽ trả về chúng trực tiếp.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 93: Trong quy trình Relaxation (slide 26), bước "Alternative Query Execution" làm gì?</p><ul class="options"><li>A. Tìm các ràng buộc có thể nới lỏng.</li><li class="correct-answer">B. Đánh giá một tập các truy vấn đã được nới lỏng và đếm số lượng item mới được truy xuất.</li><li>C. Thay đổi cách nới lỏng.</li><li>D. Tìm dạng nới lỏng cho mỗi ràng buộc.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 26 định nghĩa bước này: "a set of relaxed queries is evaluated and the new number of items retrieved is counted".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 94: (Điền đáp án) Theo slide 28, FAH là viết tắt của gì?</p><div class="explanation"><p><b>✅ Đáp án:</b> <span class="fill-in-answer">Feature Abstraction Hierarchy</span></p><p><b>💡 Giải thích:</b> Slide 28 ghi rõ "FAH (Feature Abstraction Hierarchy)".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 95: Theo slide 32, kết quả `*` (p<0.05) và `**` (p<0.01) cho thấy điều gì?</p><ul class="options"><li>A. NutKing+ hoạt động kém hơn.</li><li class="correct-answer">B. Sự khác biệt giữa NutKing+ và NutKing- là có ý nghĩa thống kê.</li><li>C. Không có sự khác biệt.</li><li>D. Dữ liệu bị lỗi.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Các ký hiệu này được dùng trong thống kê để chỉ ra rằng sự khác biệt quan sát được không phải là do ngẫu nhiên, với một mức độ tin cậy nhất định (95% cho `*` và 99% cho `**`).</p></div></div>
        <div class="question-block"><p class="question-text">Câu 96: Trong biểu đồ ở slide 35, "Relaxation Needed" thể hiện điều gì?</p><ul class="options"><li>A. Tổng số truy vấn.</li><li class="correct-answer">B. Số lượng truy vấn bị thất bại (Failing queries).</li><li>C. Số lượng truy vấn được sửa chữa thành công.</li><li>D. Số lượng truy vấn có nhiều hơn 10 ràng buộc.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> "Relaxation Needed" (Cần nới lỏng) tương đương với số lượng truy vấn không trả về kết quả nào. Trong biểu đồ, nó trùng với cột "Failing queries" đã thấy ở slide 34.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 97: Trong biểu đồ ở slide 35, "Successful Relaxation" thể hiện điều gì?</p><ul class="options"><li>A. Tất cả các truy vấn thất bại.</li><li class="correct-answer">B. Số lượng truy vấn thất bại đã được sửa chữa thành công bởi thuật toán.</li><li>C. Tổng số truy vấn.</li><li>D. Số lượng truy vấn không cần nới lỏng.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đây là tập con của các "Relaxation Needed" mà thuật toán đã tìm được ít nhất một cách nới lỏng để trả về kết quả.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 98: Trong giao diện ở slide 37, tại sao hệ thống lại đề xuất thêm ràng buộc "Cost" (Giá)?</p><ul class="options"><li>A. Vì đây là thuộc tính duy nhất còn lại.</li><li class="correct-answer">B. Vì theo tính toán của hệ thống (dựa trên Entropy, Popularity hoặc Utility), "Cost" là thuộc tính tốt nhất để giúp người dùng thu hẹp 24 kết quả hiện tại.</li><li>C. Vì người dùng đã chọn nó.</li><li>D. Vì tất cả các sản phẩm đều có giá.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Đây là hành động của Query Tightening (slide 38). Hệ thống đã tính toán điểm cho tất cả các thuộc tính chưa được ràng buộc và thấy rằng "Cost" có điểm số cao nhất.</p></div></div>
        <div class="question-block"><p class="question-text">Câu 99: Theo slide 47, một giả định mạnh của phong cách tương tác hội thoại là gì, nhưng không phải lúc nào cũng đúng?</p><ul class="options"><li>A. Người dùng luôn muốn kết quả rẻ nhất.</li><li class="correct-answer">B. Người dùng có kiến thức về thứ họ đang tìm.</li><li>C. Người dùng không muốn tương tác.</li><li>D. Người dùng luôn chấp nhận gợi ý.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 47 nêu: "The strong assumption ... is that the user is 'knowledgeable' ... This is not always true".</p></div></div>
        <div class="question-block"><p class="question-text">Câu 100: Mục đích của việc mô phỏng tương tác người-máy (Simulating human-computer interaction) trong đánh giá là gì?</p><ul class="options"><li>A. Để thay thế hoàn toàn các thử nghiệm với người dùng thật.</li><li class="correct-answer">B. Để có thể đánh giá và so sánh các thuật toán hội thoại một cách rẻ và nhanh hơn so với việc phải tiến hành các nghiên cứu tốn kém với người dùng thật.</li><li>C. Để tạo ra dữ liệu huấn luyện.</li><li>D. Để kiểm tra lỗi của giao diện.</li></ul><div class="explanation"><p><b>💡 Giải thích:</b> Slide 48 kết luận rằng việc đánh giá hệ thống hội thoại rất tốn kém vì cần người dùng thật. Ngay sau đó, slide đề xuất: "Simulating human-computer interaction could be useful", ngụ ý đây là một giải pháp thay thế hoặc bổ sung để giảm chi phí.</p></div></div>        
    </div>
</body>
</html>